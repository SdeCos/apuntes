| Algoritmo                                                          |                                                                                                                                                                                        | Características                                                                                                                                                                                                               |
| ------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **[Bubble Sort](../implementaciones/ordenacion/bubbleSort)**       | Compara pares adyacentes y los intercambia si están en desorden.                                                                                                                       | - Simple de entender<br>- Muy ineficiente para listas grandes<br>- Estable: mantiene el orden de elementos iguales                                                                                                            |
| **[Selection Sort](../implementaciones/ordenacion/selectionSort)** | Encuentra el mínimo y lo coloca al inicio de la lista no ordenada.                                                                                                                     | - No es eficiente para listas grandes<br>- Inestable en su forma básica<br>- Realiza menos intercambios que Bubble Sort                                                                                                       |
| **[Insertion Sort](../implementaciones/ordenacion/insertionSort)** | Construye la lista final un elemento a la vez, insertando cada nuevo elemento en su lugar correcto.                                                                                    | - Eficiente para listas pequeñas o parcialmente ordenadas<br>- Estable: mantiene el orden de elementos iguales<br>- Opción ideal para inserción en tiempo real                                                                |
| **[Merge Sort](../implementaciones/ordenacion/mergeSort)**         | Divide la lista en mitades, ordena cada mitad y luego las fusiona.                                                                                                                     | - Eficiente y tiene una complejidad de tiempo constante \(O(n \log n)\)<br>- Estable: mantiene el orden de elementos iguales<br>- Utiliza memoria adicional para el arreglo temporal                                          |
| **[Quick Sort](../implementaciones/ordenacion/quickSort)**         | Selecciona un 'pivote' y particiona los elementos alrededor de él antes de ordenar las sublistas.                                                                                      | - Generalmente más rápido que otros \(O(n \log n)\), pero su rendimiento depende del pivote<br>- Inestable: puede cambiar el orden de elementos iguales<br>- Puede degradarse a \(O(n^2)\) si se elige un mal pivote          |
| **[Heap Sort](../implementaciones/ordenacion/heapSort)**           | Utiliza una estructura de heap para ordenar los elementos.                                                                                                                             | - Complejidad de tiempo constante \(O(n \log n)\)<br>- Inestable: puede cambiar el orden de elementos iguales<br>- No requiere memoria adicional, a diferencia de Merge Sort                                                  |
| **[Counting Sort](../implementaciones/ordenacion/countingSort)**   | Utiliza un arreglo de conteo para organizar los elementos según su clave.                                                                                                              | - Lineal \(O(n)\) para rangos de claves pequeños<br>- Estable: puede mantener el orden de entrada de elementos iguales<br>- No adecuado para datos con claves numéricas muy dispersas                                         |
| **[Radix Sort](../implementaciones/ordenacion/radixSort)**         | Ordena los elementos digito por digito, empezando por el menos significativo.                                                                                                          | - Lineal \(O(n)\) para números de dígitos fijos<br>- Estable: adecuado para datos con múltiples dígitos<br>- Requiere una función de conteo eficiente como Counting Sort para cada dígito                                     |
| **[Bucket Sort](../implementaciones/ordenacion/bucketSort)**       | Distribuye los elementos en varios 'buckets' o contenedores y luego ordena cada bucket individualmente.                                                                                | - Eficiente cuando los datos se distribuyen uniformemente<br>- Estable si el ordenador de buckets es estable<br>- Rendimiento depende de la distribución de los datos                                                         |
| **[Intro Sort](../implementaciones/ordenacion/introSort)**         | Abreviatura de _Introspective Sort_, representa un paradigma de ordenamiento híbrido que combina estratégicamente tres algoritmos fundamentales: QuickSort, HeapSort e Insertion Sort. | - Rendimiento predecible en todos los escenarios<br>- Optimización adaptativa<br>- Eficiencia para subconjuntos pequeños<br>- Robustez frente a ataques algorítmicos<br>- Balance óptimo entre complejidad teórica y práctica |
